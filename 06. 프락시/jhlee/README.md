# 6장 프락시

이 장에서는 다음과 같은 내용을 다룬다.

- HTTP 프락시와 웹 게이트웨이를 비교하고 HTTP 프락시가 어떻게 배치되는지 설명한다.
- 프락시가 실제 네트워크에 어떻게 배치되고 트래픽이 어떻게 프락시로 유도되는지 설명한다.
- 브라우저에서 프락시를 쓰려면 **어떻게 설정하는지 설명한다.**
- **프락시 요청이 서버 요청과 어떻게 다른지**, 그리고 프락시가 브라우저 동작을 **미묘하게 바꾸는 방식**
- 여러 프락시를 지나는 메시지 경로를 **`Via` 헤더**와 **`TRACE` 메서드**로 기록하는 방법
- 프락시 기반 **HTTP 접근 제어**
- 프락시가 클라이언트/서버 사이에서 **서로 다른 기능/버전**을 지원하며 상호작용하는 방법

## 6.1 웹 중개자

- **웹 프락시 서버는 클라이언트 대신 트랜잭션을 수행하는 중개자**다.
- 트랜잭션의 “주체”는 여전히 클라이언트지만, 프락시가 제공하는 **부가 서비스**를 함께 이용하게 된다.

**프락시는 ‘서버’이면서 ‘클라이언트’다**

- HTTP 프락시는 두 역할을 동시에 한다.
    - **웹 서버 역할**: 클라이언트 요청을 받고, 커넥션/요청을 처리해서 응답을 돌려줘야 함
    - **웹 클라이언트 역할**: 그 요청을 실제 서버로 전달하고, 서버 응답을 받아 다시 클라이언트에게 전달해야 함
- 그래서 프락시를 직접 만든다면, **HTTP 서버 규칙 + HTTP 클라이언트 규칙**을 둘 다 정확히 지켜야 한다.

<img width="460" height="197" alt="image" src="https://github.com/user-attachments/assets/c893446c-0738-4787-9448-09cb91002c28" />

### 6.1.1 개인 프락시와 공유 프락시

- 프락시는 **한 명이 독점**해서 쓰기도 하고, **여러 명이 함께 공유**해서 쓰기도 한다.
    - **개인 프락시**: 한 클라이언트 전용
    - **공용 프락시**: 여러 클라이언트가 함께 사용

**공용 프락시**

- 현실에서 프락시는 보통 **공용 프락시**가 많다.
- 이유
    - 중앙에서 관리하면 **운영/관리 비용이 줄고** 더 쉽다
    - 특히 **캐시 프락시**는 사용자가 많을수록 유리하다

      → 여러 사용자의 **공통 요청**을 캐시로 처리해 이득을 보기 때문

**개인 프락시**

- 개인 프락시는 흔하진 않지만 꾸준히 쓰인다.
- 예시 목적
    - 브라우저 기능 확장
    - 성능 개선
    - 무료 ISP 서비스에서 **광고 제공** 같은 부가 기능 운영
- 이런 경우 작은 프락시가 **사용자 컴퓨터 내부에서** 동작한다.

### 6.1.2 프락시 vs 게이트웨이

- **프락시(proxy)**: **같은 프로토콜**을 쓰는 애플리케이션들 사이를 중개한다.
    - 예: 클라이언트도 HTTP, 서버도 HTTP → **HTTP 프락시**
- **게이트웨이(gateway)**: **서로 다른 프로토콜**을 쓰는 애플리케이션들을 연결한다.
    - 즉, **프로토콜 변환기**처럼 동작해서 프로토콜이 달라도 트랜잭션이 되게 해준다.

<img width="463" height="261" alt="image" src="https://github.com/user-attachments/assets/e9d5cece-91fb-43fc-9663-6ed3568b3ebf" />

- (a) 양쪽 모두 HTTP로 통신 → **HTTP 프락시**
- (b) 앞단은 HTTP, 뒷단은 POP 메일 → **HTTP/POP 게이트웨이**
    - 웹 요청을 POP 트랜잭션으로 바꿔서 “HTTP로 이메일 읽기”가 가능해짐
    - 예: Yahoo! Mail, MSN Hotmail 같은 웹메일은 “HTTP 이메일 게이트웨이” 성격
- 브라우저/서버가 서로 다른 HTTP 버전을 쓰기도 해서, 프락시가 **약간의 프로토콜 변환**을 하기도 한다.
- 상용 프락시는 SSL, SOCKS 방화벽, FTP 접근 등 지원 때문에 **게이트웨이 기능**까지 포함하는 경우가 많다.

## 6.2 왜 프락시를 사용하는가?

- 프락시 서버는 **유용하다면 뭐든지 한다.**
    - **보안 개선**
    - **성능 향상**
    - **비용 절감**
- 프락시는 클라이언트↔서버 사이의 **모든 HTTP 트래픽을 볼 수 있고, 필요하면 수정도 가능**하다.
    - 그래서 트래픽을 **감시/변형**해서 “부가가치 웹 서비스”를 만들 수 있다.

**1. 어린이 필터(필터링 프락시)**

<img width="461" height="258" alt="image" src="https://github.com/user-attachments/assets/34e777c7-8ba4-4ead-b06d-a3a3d47b26bb" />

- 학교 같은 곳에서는 프락시를 이용해
    - **교육 사이트는 허용**
    - **성인/유해 사이트는 차단**

      처럼 접근을 강제로 제어할 수 있다.

**2. 문서 접근 제어자(접근 제어 프락시)**

- 프락시는 여러 웹 서버/리소스에 대해 **단일(중앙) 접근 제어 정책**을 적용하고, **감사 추적(audit trail)** 까지 남기는 용도로 쓸 수 있다.
- 특히 **대기업**이나 서버가 여러 조직에 분산된 환경에서 유용하다.

왜 유용하냐면

- 서버가 수십/수백 대로 흩어져 있어도,
- 각 서버 설정을 매번 고치지 않고 **중앙 프락시에서 한 번에 접근 정책을 관리**할 수 있기 때문.

<img width="463" height="305" alt="image" src="https://github.com/user-attachments/assets/ccbc550a-b081-48ff-b3bf-8c7a567f7771" />

그림 예시 동작

- **클라이언트 1**: 서버의 **뉴스 페이지**에 제한 없이 접근 허용
- **클라이언트 2**: **인터넷 콘텐츠 전체**에 제한 없이 접근 허용
- **클라이언트 3**: **서버 B 접근 전 비밀번호 요구** (인증 후 접근)

**3. 보안 방화벽(프락시 방화벽)**

<img width="466" height="301" alt="image" src="https://github.com/user-attachments/assets/19b092c5-ba53-4fe3-865d-f80817ae1d5e" />

- 보안 엔지니어들은 보안을 강화하려고 **프락시 서버를 방화벽처럼** 쓰기도 한다.
- 프락시는 조직 내부로 **들어오거나 나가는 애플리케이션(응용) 계층 프로토콜 흐름**을 네트워크의 한 지점에서 **통제**한다.
- 그리고 프락시는 트래픽을 “중간에서 자세히 들여다볼 수 있는 지점(후크, hook)”을 제공해서,
    - **웹 프락시 / 이메일 프락시**에서
    - **바이러스 검사/제거** 같은 보안 기능을 붙일 수 있게 해준다.

**4. 웹 캐시(캐싱 프락시)**

- **프락시 캐시**는 인기 있는 문서(자주 요청되는 리소스)의 **로컬 사본**을 저장해 둔다.
- 같은 문서 요청이 오면 원 서버까지 가지 않고 **캐시에서 빠르게 제공**해서,
    - 느리고 비싼 **인터넷 통신(원격 통신)** 을 줄인다.

      <img width="465" height="297" alt="image" src="https://github.com/user-attachments/assets/7798d2b3-8098-43bc-b87a-ed8c5c78be88" />

- **클라이언트 1, 2**: 가까운 **웹 캐시**에서 문서를 받음(빠름, 트래픽 절감)
- **클라이언트 3, 4**: 원 서버(origin server)까지 가서 문서를 받음

**5. 대리 프락시(Surrogate) = 리버스 프락시**

- 어떤 프락시는 **웹 서버처럼 보이게(위장해서)** 동작한다.
    - 클라이언트 입장에서는 “서버에 요청”한 것처럼 보이지만,
    - 실제로는 그 프락시가 뒤에서 **원 서버(또는 다른 서버들)** 와 통신해서 콘텐츠를 찾아온다.
- 이런 프락시를 **대리 프락시(surrogate)** 또는 **리버스 프락시(reverse proxy)** 라고 부른다.

  <img width="462" height="190" alt="image" src="https://github.com/user-attachments/assets/ae4ef03d-cec6-4122-91e5-d9eb3df1f234" />

- **느린 웹 서버의 성능을 개선**하기 위해 공용 콘텐츠 앞단에 둔다.
    - 이 용도로 쓰는 대리 프락시는 흔히 **서버 가속기(server accelerator)** 라고도 부른다.
- 또, **콘텐츠 라우팅**과 결합하면
    - 요청을 상황에 맞는 서버로 보내거나,
    - **주문형 복제 콘텐츠를 여러 곳에 분산**시킨 네트워크(분산 콘텐츠 제공 구조)를 만드는 데도 활용될 수 있다.

**6. 콘텐츠 라우터(라우팅 프락시)**

- 프락시 서버는 **콘텐츠 라우터**처럼 동작할 수 있다.
- 즉, 인터넷 트래픽 상태(혼잡도 등)나 콘텐츠 종류에 따라 요청을 **특정 웹 서버로 유도(라우팅)** 한다.
- **성능/비용/정책**에 따라 “어디로 보낼지”를 달리해서 여러 서비스를 만들 수 있다.

<img width="461" height="369" alt="image" src="https://github.com/user-attachments/assets/8e3c18c1-6f19-4595-b45b-0d6dbf22a59a" />

- 사용자가(또는 콘텐츠 제공자가) **더 높은 성능을 위해 비용을 지불**했다면

  → 요청을 **가까운 복제 캐시(리플리카 캐시)** 로 전달해서 더 빠르게 응답

- 사용자가 **필터링 서비스**에 가입했다면

  → HTTP 요청이 **필터링 프락시**를 반드시 통과하도록 라우팅

**7. 트랜스코더(Transcoder) 프락시**

- 프락시는 콘텐츠를 클라이언트에게 전달하기 전에 **본문 포맷(표현 방식)** 을 바꿀 수 있다.
- 이렇게 데이터 표현을 자연스럽게 변환하는 걸 **트랜스코딩(transcoding)** 이라고 한다.

트랜스코딩 프락시가 할 수 있는 일

- **이미지 변환/최적화**
    - GIF → JPG로 변환해서 **용량 줄이기**
    - 이미지 크기 축소, 색 강도 조절(예: TV 화면에 맞게)
- **텍스트/페이지 최적화**
    - 텍스트 파일 **압축**
    - 무선 호출기/스마트폰 같은 환경을 위해 웹페이지를 **작은 텍스트 형태로 단순화**
- **번역**
    - 필요하면 문서를 **즉석에서 다른 언어로 변환**하는 것도 가능

<img width="459" height="253" alt="image" src="https://github.com/user-attachments/assets/fe971a3e-18f2-41eb-91db-42ef5408eba0" />

- 한국어 텍스트 → 스페인어 텍스트 변환
- HTML 문서 → 휴대폰 작은 화면에서도 보기 쉬운 **단순 텍스트 형태**로 변환

**8. 익명화 프락시(Anonymizer)**

- **익명화 프락시**는 HTTP 메시지에서 **신원 식별 가능 정보**를 적극적으로 제거해서
    - **개인정보 보호**
    - **익명성 강화**

      에 기여한다.

**제거/수정 대상**

- 클라이언트 **IP 주소**
- `From` 헤더
- `Referer` 헤더
- `Cookie` 헤더
- URI에 포함된 **세션 ID**

<img width="461" height="227" alt="image" src="https://github.com/user-attachments/assets/e6f5ce9d-83b6-47db-b84b-d63d66962f6e" />

- `User-Agent`에서 사용자의 **컴퓨터/OS 정보** 제거
- 이메일 주소 노출 방지를 위해 `From` 헤더 제거
- 방문 경로 추적을 어렵게 하려고 `Referer` 헤더 제거
- 프로필/신원 정보 제거를 위해 `Cookie` 헤더 제거

## 6.3 프락시는 어디에 있는가?

- **프락시가 네트워크에서 어디에 배치되고 언제 등장하는지**를 다룬다.

이 절에서 다룰 내용

- **프락시가 네트워크에 어떻게 배치되는가**
- **프락시가 여러 개 연결되어 연쇄(체인)·계층 구조를 이루는 방식**
- **클라이언트 트래픽이 어떻게 ‘올바른 프락시’로 흘러가게 되는가**

### 6.3.1 프락시 서버 배치

- 프락시는 “어떤 목적으로 쓰느냐”에 따라 **네트워크 어디든** 배치될 수 있다.
- 대표 배치 방식은 아래 4가지다.

<img width="459" height="563" alt="image" src="https://github.com/user-attachments/assets/5dd6a177-2c45-49bb-aa7e-4fd3ad6da2c7" />

**1. 출구(Egress) 프락시**

- **로컬 네트워크 ↔ 인터넷** 사이(회사/학교 네트워크의 출구)에 둔다.
- 목적
    - 외부의 악의적 접근을 막는 **방화벽/보안 관문**
    - **인터넷 비용 절감**, 트래픽 최적화(캐시 등)
    - 학교라면 **유해 사이트 필터링** 같은 정책 적용

**2. 접근(입구) 프락시**

- ISP 같은 곳에서 사용자 요청을 **앞단에서 한꺼번에 처리**하려고 둔다.
- 목적
    - 사용자 **다운로드 속도 개선**(특히 고속 접속 사용자 체감)
    - ISP의 **대역폭 비용 절감**
    - 많이 찾는 문서 사본을 쌓아두는 **캐시 프락시**가 대표적

**3. 대리 프락시(Surrogate) = 리버스 프락시**

- **웹 서버 바로 앞단**(서버 쪽 네트워크 끝)에 둔다.
- 동작
    - 서버로 가는 모든 요청을 먼저 받고,
    - 필요할 때만 뒤의 웹 서버에 요청해서 가져온다.
- 목적
    - 웹 서버 앞에 **보안 기능 추가**
    - 빠른 캐시를 앞에 둬서 **성능 개선(서버 가속기 역할)**
- 특징
    - 보통 **웹 서버의 이름/IP로 “자기 자신을 서버처럼” 보이게** 해서 요청이 프락시로 오게 만든다.

**4. 네트워크 교환 프락시(피어링/교환 지점)**

- 인터넷의 **교환 지점(피어링 포인트)** 같은 “트래픽 교차로”에 둘 수 있다.
- 목적
    - 캐시로 **혼잡 완화**
    - 트래픽 흐름 **감시/관찰**
    - 대규모 트래픽을 다루기 위한 충분한 처리 능력이 전제됨

### 6.3.2 프락시 계층

- 프락시는 **여러 대가 연쇄(체인)** 로 연결되어 *프락시 계층*을 이룰 수 있다.
- 이 구조에서는 HTTP 메시지가
    - 클라이언트 → (프락시들) → 원 서버
    - 원 서버 → (프락시들) → 클라이언트

      처럼 **여러 프락시를 거쳐 왕복**한다.

**부모/자식 프락시 개념**

- 프락시 계층에서 프락시들은 **부모–자식 관계**로 부른다.
- 기준은 “원 서버에 더 가깝냐/클라이언트에 더 가깝냐”다.

정의

- **부모 프락시(parent)**: 다음 hop에서 **서버 쪽(원 서버에 더 가까운) 프락시**
- **자식 프락시(child)**: 다음 hop에서 **클라이언트 쪽(클라이언트에 더 가까운) 프락시**

<img width="464" height="160" alt="image" src="https://github.com/user-attachments/assets/169c9a24-4886-4ef4-8f63-b5299a138f0f" />

- 프락시 2 → 프락시 3으로 보낸다면
    - **프락시 2는 프락시 3의 자식**
    - **프락시 3은 프락시 2의 부모**

### **프락시 계층 콘텐츠 라우팅**

- 앞에서 본 프락시 계층(그림 6-12)은 **정적(static)** 구조다.
    - 프락시 1 → 항상 프락시 2
    - 프락시 2 → 항상 프락시 3
- 하지만 현실의 계층은 꼭 고정일 필요가 없다. 프락시는 상황에 따라 **여러 부모 프락시 / 원 서버 후보 중 어디로 보낼지 동적으로 선택**할 수 있다.

예: 접근 프락시가 “부모 프락시 vs 원 서버”를 상황별로 선택

<img width="462" height="290" alt="image" src="https://github.com/user-attachments/assets/13f8e1d8-a0cf-4e98-83ae-050f6f7212c8" />

- **특정 콘텐츠 제공자가 CDN/콘텐츠 분산 비용을 지불한 경우**
    - 가까운 **캐시 서버**로 보내서 캐시된 객체를 주거나,
    - 캐시에 없으면 원 서버에서 가져오게 한다.
- **특정 종류의 이미지 요청인 경우**
    - 요청을 **압축(트랜스코딩) 프락시**로 보내서
    - 이미지를 가져와 압축한 뒤, 느린 회선(예: 모뎀)에서도 빨리 받게 한다.

**동적 부모 선택(라우팅) 기준 예시**

- **부하 균형(Load balancing)**
    - 자식 프락시가 부모 후보들의 **현재 부하/작업량**을 보고 덜 바쁜 쪽을 선택
- **지리적 인접성 기반 라우팅**
    - 원 서버와 **가까운 지역을 담당**하는 부모 프락시를 선택
- **프로토콜/타입 라우팅**
    - URI 패턴에 따라 다른 부모/원 서버로 보냄
    - 어떤 요청은 **특별한 프락시**로 보내서 **다른 프로토콜/처리 방식**을 적용
- **유료 서비스 가입자 라우팅**
    - 추가금을 낸 고객의 요청은 **대형 캐시/압축 엔진** 같은 “고성능 경로”로 우선 라우팅

### 6.3.3 어떻게 프락시가 트래픽을 처리하는가

- 클라이언트는 원래 **웹 서버와 직접 통신**한다.
- 그래서 “HTTP 트래픽이 어떻게 프락시로 향하게 되는지”를 알아야 한다.
- 트래픽을 프락시로 보내는 방법은 **4가지**다.

<img width="466" height="321" alt="image" src="https://github.com/user-attachments/assets/a63aa276-cfb2-4a20-9a37-bf5b4e763c5b" />

1. **클라이언트를 수정한다 (브라우저/앱 설정)**
    - 크롬 같은 브라우저는 **수동/자동 프락시 설정**을 지원한다.
    - 프락시 사용으로 설정되면, 클라이언트는 HTTP 요청을 **원 서버가 아니라 프락시로 직접** 보낸다.
2. **네트워크를 수정한다 (인터셉트 프락시)**
    - 클라이언트가 모르는 상태에서 네트워크 인프라가 트래픽을 **가로채서 프락시로 우회**시킨다.
    - 보통 HTTP 트래픽을 감시/가로채는 **스위칭 장치, 라우팅 장치**가 필요하다.
    - 이런 방식을 **인터셉트 프락시(intercept proxy)** 라고 부른다.
3. **DNS 이름공간을 수정한다 (대리/리버스 프락시 유도)**
    - 웹 서버 앞의 **대리 프락시(리버스 프락시)** 는 웹 서버의 **이름/IP를 자신이 직접 사용**한다.
    - 그래서 클라이언트 요청이 “서버로 가는 것처럼 보여도” 실제로는 **대리 프락시로 먼저** 간다.
    - EX)
        - DNS 테이블을 수동 편집하거나
        - 적절한 목적지를 계산해주는 **동적 DNS**로 조정한다.
    - 어떤 구성에서는 “원래 서버의 IP/이름”을 바꾸고, **대리 프락시가 기존 주소/이름을 가져간다.**
4. **웹 서버를 수정한다 (305 리다이렉션)**
    - 서버가 클라이언트에게 **HTTP 리다이렉션(305)** 을 보내서

      클라이언트가 **프락시로 다시 요청**하게 만들 수 있다.

    - 리다이렉션을 받으면 클라이언트는 즉시 **프락시와 트랜잭션을 시작**한다.

## 6.4 클라이언트 프락시 설정

- 요즘 브라우저는 대부분 **프락시를 쓰도록 설정**할 수 있다.
- 그리고 프락시 설정 방식도 **여러 가지**를 제공한다.
1. **수동 설정**
- 보통 프락시 서버 주소/포트 등을 직접 입력하는 방식이다.
2. **브라우저 기본 설정**
- 브라우저 벤더나 배포자가 브라우저(또는 웹 클라이언트)를 사용자에게 전달하기 전에 **프락시 값을 미리 세팅**해둘 수 있다.
3. **프락시 자동 설정(PAC: Proxy Auto-Configuration)**
- 클라이언트에게 **PAC 파일(자바스크립트 파일)의 URI**를 제공한다.
- 브라우저는 그 JS 파일을 **가져와서 실행**하고,
    - "프락시를 써야 하는지"
    - "쓴다면 어떤 프락시를 써야 하는지"
  를 **판단**한다.
4. **WPAD 프락시 발견(WPAD: Web Proxy Auto-Discovery Protocol)**
- 브라우저가 "PAC 파일을 내려줄 설정 서버"를 **자동으로 찾아주는 프로토콜**이다.
- 즉, 사용자가 URL을 직접 넣지 않아도 **자동 설정(PAC) 경로를 발견**해서 적용할 수 있다.

### 6.4.1 클라이언트 프락시 설정: 수동

- 많은 웹 클라이언트는 **프락시를 수동으로 설정**할 수 있다.
- 핵심 아이디어는 단순하다: **프락시 서버의 호스트(host)와 포트(port)를 지정**한다.

**추가 포인트**

- 브라우저마다 메뉴 위치는 달라도, 결국 “프락시 주소/포트 넣기”는 같다.
- 일부 ISP는 아예 **프락시가 미리 설정된 브라우저/운영체제**를 제공하거나, **웹 트래픽을 프락시로 강제 리다이렉트**하는 방식도 쓴다.

### 6.4.2 클라이언트 프락시 설정: PAC 파일

- **수동 프락시 설정**은 단순하지만 **유연하지 못하다.**
    - 보통 **모든 트래픽에 프락시 1개만** 지정 가능
    - 큰 조직에서는 브라우저가 너무 많아서 **일괄 변경/관리 자체가 어려움**
- 그래서 나오는 게 **PAC(Proxy Auto-Configuration) 파일**이다.
    - PAC는 “프락시를 고정으로 박는 설정”이 아니라,
    - **상황에 맞게 매번 프락시를 계산해주는 작은 JavaScript 프로그램**이다.
    - 즉, **문서(URI)에 접근할 때마다** JS 함수가 "이번 요청은 어느 프락시로 보낼지"를 결정한다.

**PAC를 쓰는 방식**

- 브라우저 설정에서 **PAC 파일의 URI를 등록**한다.
    - 수동 프락시 설정이랑 비슷한데,
    - 차이점은 “자동 설정(automatic configuration)” 쪽에 **PAC 파일 URI를 넣는 것**이다.
- 그러면 브라우저는:
    1. PAC 파일을 가져오고
    2. 매 요청마다 PAC의 로직을 실행해서
    3. 적절한 프락시(또는 직접 연결)를 선택한다.

**PAC 파일의 형식**

- 보통 확장자: **`.pac`**
- MIME 타입: **`application/x-ns-proxy-autoconfig`**

**핵심 규칙: 반드시 이 함수를 정의해야 함**

- 모든 PAC 파일은 아래 함수를 제공해야 한다.
- `FindProxyForURL(url, host)`
    - 입력: 요청 URL, 호스트
    - 출력: “이 요청을 어떻게 보낼지”를 나타내는 문자열

      <img width="461" height="124" alt="image" src="https://github.com/user-attachments/assets/a933d9af-f945-40f3-853e-51c23888b966" />

```jsx
function FindProxyForURL(url, host) {
  if (url.substring(0, 5) == "http:") {
    return "PROXY http-proxy.mydomain.com:8080";
  } else if (url.substring(0, 4) == "ftp:") {
    return "PROXY ftp-proxy.mydomain.com:8080";
  } else {
    return "DIRECT";
  }
}
```

- HTTP 요청이면 HTTP 프락시로
- FTP 요청이면 FTP 프락시로
- 그 외는 직접 연결로
- 요청의 종류(스킴)에 따라 프락시를 다르게 선택할 수 있다.

### 6.4.3 클라이언트 프락시 설정: WPAD

- 브라우저 프락시 설정을 자동화하는 또 다른 메커니즘은 **WPAD(Web Proxy Auto-Discovery Protocol)** 이다.
- WPAD의 목적은 한 줄로 말하면 이거다:

> **브라우저가 "알맞은 PAC 파일"을 자동으로 찾아서 적용하게 해주는 방식**

**WPAD로 브라우저가 하는 일(흐름)**

WPAD를 지원하는 클라이언트(브라우저)는 보통 다음 순서로 동작한다.

1. **WPAD로 PAC 파일 위치를 찾는다**
2. **찾아낸 URI에서 PAC 파일을 가져온다**
3. **PAC 파일을 실행해서 사용할 프락시 서버를 계산한다**
4. **그 프락시 서버로 요청을 처리한다**

즉, WPAD는 “프락시 서버를 직접 찾아주는 것”이라기보다,

**PAC 파일을 자동으로 발견해서 그 PAC 로직으로 프락시를 결정하게 하는 방식**이다.

**WPAD가 PAC 파일을 찾는 방법(성공할 때까지 순서대로 시도)**

조직마다 가능한 방법이 다르기 때문에, WPAD는 여러 발견 기법을 **하나씩 시도**한다.

현재 명세가 정의하는 시도 순서는 다음과 같다.

1. **DHCP 기반 발견** (동적 호스트 발견 규약)
2. **SLP 기반 발견** (서비스 위치 규약)
3. **DNS “well-known host name”** 방식
4. **DNS SRV 레코드**
5. **DNS TXT 레코드 안의 서비스 URI**

## 6.5 프락시 요청의 미묘한 특징들

이 절에서는 **프락시 요청에서 오해하기 쉬운 미묘한 차이**를 다룬다.

- **프락시로 보내는 요청의 URI**가 **서버로 보내는 요청의 URI**와 어떻게 다른가
- **인터셉트 프락시 / 리버스 프락시**가 왜 **서버 호스트 정보 파악을 어렵게** 만드는가
- **URI 수정에 대한 규칙**
- 프락시가 브라우저의 **URI 자동완성 / 호스트명 확장 기능**에 어떤 영향을 주는가

<img width="461" height="448" alt="image" src="https://github.com/user-attachments/assets/1f7aa1a4-1c23-4b21-b949-71d4f8a5c673" />

### 6.5.1 프락시 URI는 서버 URI와 다르다

- **문법은 같지만 “요청줄의 URI 형태”가 다르다.**

**1) 서버로 직접 요청할 때: 부분 URI**

- 스킴/호스트/포트 없이 **경로만** 보냄

```
GET /index.html HTTP/1.0
User-Agent: SuperBrowser v1.3
```

- 원래 HTTP는 **클라이언트 ↔ 단일 서버 직접 통신**을 전제로 했고, 서버는 자기 **호스트/포트**를 이미 아니까 굳이 안 보냄

**2) 프락시로 요청할 때: 완전한 URI**

- 스킴/호스트/포트까지 포함한 **absolute URI**를 요청줄에 넣음

```
GET http://www.marys-antiques.com/index.html HTTP/1.0
User-Agent: SuperBrowser v1.3
```

- 프락시는 **목적지 서버로 다시 연결**해야 하니까 **서버 이름(호스트)** 이 필요하고, 게이트웨이 역할이면 **스킴(예: http/ftp)** 도 필요하다.

**3) 왜 둘을 통일 못 했나?**

- HTTP/1.0에서 프락시 요청은 **완전한 URI**로 해결했지만,
- 서버 요청까지 전부 완전한 URI로 바꾸기엔 **이미 배포된 서버가 너무 많아서**(호환성) **부분 URI 방식이 남았다**.

**4) 클라이언트 동작 규칙**

- **프락시 미설정** → 서버로 **부분 URI** 전송
- **프락시 설정** → 프락시로 **완전한 URI** 전송

### 6.5.2 가상 호스팅에서 일어나는 같은 문제

- 가상 호스팅 서버는 **한 대의 물리 서버**에서 **여러 웹사이트(도메인)** 를 함께 서비스한다.
- 그런데 요청줄이 **부분 URI**로만 오면 예) `GET /index.html HTTP/1.1`
- 서버 입장에선 “이 `/index.html`이 **어느 사이트의** `/index.html`인지”를 구분해야 한다.
- 즉, **목적지 호스트(도메인) 정보가 없으면 docroot/설정을 선택할 수 없다.**
- **프락시의 ‘스킴/호스트/포트번호 누락’ 문제와 닮은 점**
    - 둘 다 “요청줄에 **host 정보가 없어서** 목적지를 특정하기 어렵다”는 점이 같다.
    - 프락시는 “어느 서버로 연결해야 하는지”가 문제고,
    - 가상 호스팅 서버는 “어느 가상호스트(docroot/설정)로 처리해야 하는지”가 문제다.
- **해결 방식**
    1. **명시적 프락시(explicit proxy)**
        - 클라이언트가 프락시로 요청을 보낼 때 **요청줄에 완전한 URI**를 넣도록 규칙이 정리됐다.
        - 예) `GET http://www.marys-antiques.com/index.html HTTP/1.1`
    2. **가상 호스팅 웹 서버**
        - 요청줄은 그대로 부분 URI여도 되지만,
        - 대신 요청 헤더에 **`Host` 헤더(호스트 + 필요시 포트)** 를 **필수로 요구**하는 쪽으로 해결됐다.
        - 예)
            - `GET /index.html HTTP/1.1`
            - `Host: www.marys-antiques.com`

### 6.5.3 인터셉트 프락시는 부분 URI를 받는다

- 클라이언트가 HTTP를 “정상적으로” 구현했고, **프락시를 명시적으로 설정(explicit proxy)** 해둔 경우
    - 프락시로 요청을 보낼 때 **요청줄에 완전한 URI**를 보낸다.
    - 예) `GET http://host/path HTTP/1.1`
- 그런데 항상 이렇게 되지는 않는다.
    - 어떤 프락시는 **클라이언트 입장에선 존재가 보이지 않을 수 있다.**
    - 그래서 클라이언트가 “나는 프락시와 대화 중”이라고 **인식하지 못한 채** 요청을 보낼 수 있다.
- 프락시를 설정하지 않았어도 트래픽이 프락시를 지나는 대표 케이스 2가지
    1. **대리(리버스) 프락시**
        - 원 서버의 **호스트명/IP**를 그대로 사용해서 원 서버 “앞”에 서는 프락시다.
        - 클라이언트는 원 서버로 접속한다고 생각하지만, 실제로는 프락시로 들어간다.
    2. **인터셉트 프락시(intercept proxy)**
        - 네트워크 중간에서 클라이언트→서버 트래픽을 **가로채서** 프락시로 보내는 방식이다.
        - 캐시 응답 반환 같은 처리를 할 수 있다.
- 이 두 경우의 공통 결과
    - 클라이언트는 자신이 서버와 통신한다고 믿기 때문에,
    - 요청줄에 **완전한 URI가 아니라 “부분 URI(path만)”** 를 보낸다.
    - 예) `GET /index.html HTTP/1.1`
- 따라서 **인터셉트 프락시는 “부분 URI 요청”을 받는 상황이 생긴다.**
    - 이유: 애초에 클라이언트가 프락시를 대상으로 요청을 만든 게 아니라,
    - “서버로 보내는 요청”을 네트워크에서 중간에 가로챈 것이기 때문.

### 6.5.4 프락시는 프락시 요청과 서버 요청을 모두 다룰 수 있다.

- 다목적 프락시 서버는 **프락시로 직접 들어오는 요청(프락시 요청)** 과 **일반 웹 서버로 가는 요청(서버 요청)** 을 모두 처리해야 한다.
- 트래픽이 프락시로 들어오는 방식이 여러 가지라서, 프락시는 요청 라인의 URI가 **완전 URI(absolute URI)** 일 수도 **부분 URI(경로만)** 일 수도 있다는 점을 모두 지원해야 한다.

**프락시가 원 서버를 결정하는 규칙**

1. **완전 URI가 있으면** → 그 URI를 그대로 사용한다.
2. **부분 URI이고 Host 헤더가 있으면** → Host 헤더로 원 서버의 호스트/포트를 알아낸다.
3. **부분 URI인데 Host 헤더가 없으면** →
    - (a) 프락시가 특정 원 서버를 대신하는 **대리 프락시(리버스 프락시)** 라면, 프락시 설정에 있는 서버 주소/포트를 사용한다.
    - (b) **인터셉트(투명) 프락시**에서 넘어온 트래픽이라면, 보존된 원래 목적지 IP/포트를 사용한다.
    - (c) 그래도 못 찾으면 → 원 서버 정보가 부족하므로 **에러 응답**을 반환한다(보통 Host 헤더 지원 브라우저 사용 안내).

### 6.5.5 전송 중 URI 변경 요약

- 프락시 서버는 **요청 URI를 바꾸는 일에 매우 신중**해야 한다. 겉보기엔 사소한 변경이라도 **다운스트림 서버와의 호환성(상호운용성) 문제**를 일으킬 수 있다.
- 일부 프락시는 다음 홉으로 보내기 전에 URI를 **정규화(normalize)** 하기도 하는데, 이런 “무해해 보이는” 변형도 문제를 만들 수 있다. 예:
    - 기본 포트를 `:80`처럼 **명시적으로 붙이는 변경**
    - 잘못 쓰인 예약 문자를 **올바르게 이스케이프 처리로 교체**하는 변경
- 원칙적으로 프락시는 가능한 한 **관대하게 동작**해야 하며, 프로토콜을 엄격히 강제하는 **‘프로토콜 경찰’**처럼 행동하면 기존에 잘 되던 동작을 깨뜨릴 수 있다.
- 특히 HTTP 명세는 **일반적인 인터셉트(투명) 프락시가 URI를 전달할 때 절대 경로를 고쳐 쓰는 것을 금지**한다.
- **허용되는 유일한 예외**는, **빈 경로(empty path)를 `/`로 바꾸는 것**뿐이다.

### 6.5.6 URI 클라이언트 자동확장과 호스트명 분석 요약

- 브라우저는 **프락시가 있느냐 없느냐**에 따라 **요청 URI를 해석하는 방식이 달라진다.**

**프락시가 없을 때(직접 접속)**

- 사용자가 입력한 URI/호스트명을 바탕으로 **DNS로 IP 주소를 찾는다.**
- 호스트명이 해석되면, 나온 **여러 IP 주소를 연결이 될 때까지 순서대로 시도**한다.

**호스트명이 바로 해석되지 않을 때(자동 확장/보정)**

많은 브라우저/시스템은 사용자가 짧게 입력했거나 오타가 있다고 보고 **자동으로 “확장/보정”**을 시도한다.

- **www / .com 자동 보정**: `yahoo`만 입력해도 `www.yahoo.com`처럼 추정해서 시도하는 브라우저가 많다.
- **서드파티 오타 교정 사이트로 전달**: 해석 불가능한 URI를 외부 서비스로 넘겨 오타를 교정하고 “의도했을 주소”를 제안하는 브라우저도 있다.
- **DNS 검색 도메인(서픽스) 자동 붙이기**: 시스템 DNS 설정에 따라 `host7`처럼 앞부분만 입력하면 현재 도메인(예: `oreilly.com`)을 붙여 `host7.oreilly.com` 같은 이름을 자동으로 찾아본다.

### 6.5.7 프락시 없는 URI 분석(URI Resolution) 요약

- 프락시가 없는 환경에서 브라우저는 사용자가 입력한 값이 **유효한 호스트명으로 해석될 때까지** 여러 후보를 만들어 **순차적으로 DNS 조회/접속 시도**를 한다.

  <img width="464" height="257" alt="image" src="https://github.com/user-attachments/assets/e284d5dc-72ab-4d1f-ae29-25169b45be45" />

1. 사용자가 주소창에 `oreilly`를 입력하면, 브라우저는 이를 **호스트명**으로 보고 기본값을 붙여 해석한다.
    - 기본 스킴: `http://`
    - 기본 포트: `80`
    - 기본 경로: `/`
2. 브라우저는 먼저 `oreilly` 자체를 호스트로 DNS 조회/접속 시도하지만 **실패**한다.
3. 실패하면 브라우저가 호스트명을 **자동 확장**해서 `www.oreilly.com` 같은 형태로 만들어 DNS에 resolve를 요청한다.
4. `www.oreilly.com` 해석이 **성공**하면, 브라우저는 그 주소로 **연결에 성공**한다.

### 6.5.8 명시적인 프락시를 사용할 때의 URI 분석 요약

- **명시적 프락시(explicit proxy)** 를 쓰면, 브라우저는 프락시가 없을 때 하던 **편리한 자동확장(호스트명 보정/확장)** 을 더 이상 제대로 수행할 수 없다.

<img width="457" height="283" alt="image" src="https://github.com/user-attachments/assets/e412a66d-e52d-4ba0-9d66-226aae58c265" />

- 명시적 프락시가 설정된 경우 브라우저는 **부분 호스트명(예: `oreilly`)을 `www.oreilly.com`처럼 자동확장하지 않는다.**
- 사용자가 주소창에 `oreilly`를 입력하면 브라우저는 보통:
    - **기본 스킴**과 **기본 경로**는 붙여서 `http://oreilly/` 형태로 만들지만
    - **호스트명 자체는 입력한 그대로**(oreilly) 유지한다.
- 그 결과 프락시는 `http://oreilly/` 같은 요청을 받게 된다(= 호스트가 완전하지 않을 수 있음).
- 이런 불편을 줄이기 위해, 일부 프락시는 브라우저가 하던 것처럼
    - `www.` 붙이기
    - `.com` 또는 지역 도메인 접미사 붙이기

      같은 **자동확장 기능을 프락시 쪽에서 흉내 내려고** 시도하기도 한다.

## 6.5.9 인터셉트 프락시에서의 URI 분석

- **인터셉트 프락시**는 클라이언트(브라우저) 입장에서는 **프락시가 없는 것처럼 보이는** 구조다.
- 그래서 브라우저의 **호스트명 자동확장 + DNS 조회 동작**은 프락시가 없을 때와 거의 동일하게 진행된다.
- 차이는 커넥션**이 만들어지는 순간** 발생한다. 브라우저는 “원 서버에 연결했다”고 생각하지만, 실제로는 **인터셉트 프락시가 그 연결을 가로채서 자신에게 종료**시킨다.

<img width="457" height="226" alt="image" src="https://github.com/user-attachments/assets/b7d52297-a169-4d59-abf6-099664f112c5" />

1. 사용자가 주소창에 `oreilly` 입력
2. DNS로 `oreilly` 조회 → 실패(호스트를 모름)
3. 브라우저가 자동확장 수행 → `www.oreilly.com` 같은 후보로 바꿔 DNS 재조회
4. DNS 성공 → 브라우저는 IP 주소 목록을 얻고, 보통은 **여러 IP를 순서대로 시도**하며 살아있는 서버를 찾음
5. 그런데 인터셉트 프락시 환경에서는 **첫 번째 접속 시도 자체가 원 서버가 아니라 프락시에서 “성공” 처리**된다
    - 즉, 브라우저는 “서버랑 연결됐다”고 믿지만
    - 실제 원 서버 IP는 **죽어있을 수도** 있고, 브라우저는 그 사실을 아직 모른다.
- 프락시가 실제 원 서버로 연결하려고 했을 때, 선택된 IP가 **다운된 서버**일 수 있다.
- 브라우저 수준의 **장애 허용(fault tolerance)** 을 제공하려면 프락시가 대신 다음을 해야 한다:
    - Host 헤더의 호스트명을 다시 DNS로 조회해서 **다른 IP들을 시도**하거나
    - IP에 대해 **역방향 DNS 조회** 등을 활용해 다른 후보를 찾아 **재시도**해야 한다.
- **인터셉트 프락시든 명시적 프락시든**, “죽은 서버/죽은 IP” 상황에서의 **DNS 재시도(장애 허용)는 프락시가 책임져야 한다.**
- 특히 **명시적 프락시**를 쓰는 경우엔 브라우저가 원 서버와 직접 연결하지 않으니, 장애 허용 능력이 **프락시 품질에 더 크게 의존**한다.

## 6.6 메시지 추적 요약

<img width="461" height="213" alt="image" src="https://github.com/user-attachments/assets/4ef6aaf1-a7ec-420d-9c55-6e9b5a6bf054" />

- 오늘날 웹 요청은 클라이언트→서버로 가는 동안 **프락시를 2개 이상 거치는 경우가 흔하다.**
    - 회사들은 **보안/비용 절감**을 위해 **캐시 프락시**를 사용하고,
    - 대형 ISP들도 **성능 개선/기능 제공**을 위해 **프락시 캐시**를 사용한다.
- 또한 성능을 위해 전 세계에 분산된 **대리(리버스) 캐시 저장소에 콘텐츠를 복제**해두는 구조도 점점 일반적이다.
- 프락시는 **여러 벤더/조직**이 각자 만들고 운영하므로, 기능과 버그가 제각각이다.
- 그래서 이제는 IP 패킷 경로 추적만큼이나, **프락시들을 거치며 메시지가 어떻게 흘렀는지 추적하고 문제를 찾는 것(메시지 추적)** 이 중요해졌다.

### 6.6.1 Via 헤더 요약

<img width="456" height="194" alt="image" src="https://github.com/user-attachments/assets/ec0683fe-68de-4e69-8d47-66cc535afa83" />

- **Via 헤더**는 HTTP 메시지가 지나간 **중간 노드(프락시/게이트웨이) 정보**를 순서대로 나열한다.
- 메시지가 새 노드를 지날 때마다, 그 노드는 **Via 목록의 맨 끝에 자신을 추가**해야 한다.

```jsx
Via: 1.1 proxy-62.irenes=isp.net, 1.0 cache.joes-hardware.com

```

→ 메시지가 **두 개의 프락시**를 거쳤고,

- 첫 번째 프락시는 **HTTP/1.1** 구현 + proxy-62.irenes=isp.net라고 불리고
- 두 번째 프락시는 **HTTP/1.0** 구현 + [cache.joes-hardware.com](http://cache.joes-hardware.com)라고 불린다

**Via 헤더의 용도**

- 메시지가 어떤 경로로 전달됐는지 **추적**
- 프락시를 오가며 생기는 **메시지 루프(순환) 진단**
- 요청/응답에 관여한 각 노드가 **어떤 HTTP 버전을 처리할 수 있는지** 파악

**루프(라우팅 루프) 탐지**

- 프락시는 요청을 보내기 전에 Via에 **자기만의 고유 문자열**을 넣고,
- 들어온 요청의 Via에 그 문자열이 이미 있으면 **루프가 발생했다**고 판단해 탐지할 수 있다.

### Via 문법

- **Via 헤더**는 쉼표로 구분된 **경유지(waypoint) 목록**이다.
- 각 waypoint는 메시지가 지나간 **프락시/게이트웨이 1개**를 의미하며, 그 노드의 **프로토콜/버전/이름(주소)/코멘트** 정보를 담는다.

### 기본 형식(개념)

- `Via: <waypoint>, <waypoint>, ...`
- `waypoint = received-protocol received-by [comment]`

### waypoint에 들어갈 수 있는 구성요소(최대 4개)

1. **프로토콜 이름(선택)**
    - 중개자가 받은 프로토콜
    - HTTP면 보통 생략 가능(기본이 HTTP)
    - 비HTTP(HTTPS, FTP 등) ↔ HTTP 변환이 있을 때(게이트웨이) 나타날 수 있음
    - 있으면 `이름/버전` 형태로 표시
2. **프로토콜 버전(필수)**
    - 수신한 메시지의 버전(HTTP라면 `1.0`, `1.1` 등)
    - 이를 통해 요청/응답 경로상의 중개자들이 **어떤 버전을 처리 가능한지** 파악 가능
3. **노드 이름 received-by(필수)**
    - 보통 `host[:port]` 형태
    - 포트가 없으면 해당 프로토콜의 **기본 포트**로 간주
    - 정보 노출이 싫으면 실제 호스트 대신 **가명** 사용 가능
4. **코멘트(선택)**
    - 중개자 설명용 메모
    - 벤더/버전 정보, 진단용 이벤트 정보 등을 넣기도 함

### Via 요청과 응답 경로

<img width="462" height="226" alt="image" src="https://github.com/user-attachments/assets/cfaed3d7-2fb1-465c-828a-3ebecf2814ba" />

- **요청과 응답 모두 프락시를 지나가기 때문에**, 둘 다 **Via 헤더를 포함**한다.
- 보통 요청/응답은 **같은 TCP 커넥션**을 통해 오가므로, **응답은 요청이 지나온 경로를 그대로 역순으로 되돌아간다.**
- 따라서 요청이 `A → B → C` 프락시를 거쳤다면,
    - 응답은 `C → B → A`로 돌아오고,
    - **응답의 Via 헤더 순서는 보통 요청 Via 헤더의 역순**이 된다.

### Via와 게이트웨이

- 일부 프락시는 **게이트웨이**처럼 동작해서 서버 쪽과는 **HTTP가 아닌 프로토콜(예: FTP)** 로 통신할 수 있다.
- **Via 헤더는 이런 “프로토콜 변환”이 있었음을 기록**해준다.

  → 그래서 HTTP 애플리케이션은 프락시 체인 중간에 **어떤 프로토콜을 사용했는지**, **변환이 있었는지**를 추적할 수 있다.

<img width="455" height="274" alt="image" src="https://github.com/user-attachments/assets/d5d5b2dc-4ec6-44ea-bf3a-6b4d3d7c26ad" />

- 클라이언트가 `ftp://http-guide.com/pub/welcome.txt` 리소스를 요청하지만,
    - 요청 자체는 **HTTP로 게이트웨이 프락시**(예: `proxy.irene...`)에 보낸다.
- 게이트웨이 프락시는 서버 쪽과는 **FTP로 접속**해서 파일을 받아온다.
- 그리고 클라이언트에게는 **HTTP 응답**으로 돌려주되, Via에 다음처럼 남긴다:
    - `Via: FTP/1.0 proxy.irene... ( ... )`
    - `FTP/1.0`처럼 **수신(또는 사용) 프로토콜이 FTP**로 기록된 걸 보면,
        - “이 프락시는 게이트웨이로 동작했고, HTTP↔FTP 변환이 있었다”를 알 수 있다.
- Via의 코멘트에는 종종 **제품/버전/진단 정보** 같은 부가정보가 들어간다.

### Server 헤더와 Via 헤더

- **Server 응답 헤더**는 **원 서버(Origin Server)** 가 어떤 소프트웨어(웹서버/플랫폼 등)로 응답했는지 알려준다.
    - 예: `Server: Apache/...`, `Server: Microsoft-IIS/...` 등
- 응답이 프락시를 통과하더라도 **프락시는 Server 헤더를 수정하면 안 된다.**
    - Server 헤더는 **원 서버 정보**를 나타내기 위한 것이기 때문.
- 프락시가 자신의 흔적을 남기거나 경로를 기록하려면, **Server를 건드리는 게 아니라 Via에 자기 항목을 추가**해야 한다.

### Via가 개인정보 보호와 보안에 미치는 영향

- Via 헤더에 **정확한 호스트명/포트**가 그대로 노출되면, 특히 프락시가 **방화벽(보안 경계) 뒤**에 있을 때 내부 네트워크 구조 정보가 새어 나가 **공격에 악용**될 수 있다.
- 그래서 보안 경계에 있는 프락시는(명시적으로 허용된 경우가 아니면) **방화벽 뒤 호스트의 실제 이름/포트를 Via에 전달하면 안 된다.**

### 대안: 가명사용

- 실제 호스트명을 Via에 쓸 수 없으면, 프락시는 **적절한 가명으로 치환**해야 한다.
- 다만 실제 이름을 숨기더라도, 가능하면 **경로 추적을 위해 Via 경유지 항목 자체는 유지**하려고 해야 한다(“누가 몇 번 거쳤는지”는 남기되, “정확히 누구인지”는 숨김).

### 더 강한 보안 요구: Via 항목 합치기

- 내부 토폴로지(구성/구조)를 더 숨기고 싶은 조직은, 프락시가 **여러 Via 경유지 항목을 하나로 합쳐** 표시할 수 있다.
- 단, 합칠 때는 엄격한 조건이 있다:
    - **수신된 프로토콜 값이 같은 항목들만** 합칠 수 있다(예: 모두 `1.1`).
    - **같은 조직 통제하에 있는 프락시들**이고, 필요 시 **가명 처리까지 된 경우**에만 합쳐야 한다.
    - **프로토콜 값이 다른 항목(예: 1.0과 1.1)은 합치면 안 된다.**

### 6.6.2 TRACE 메서드

- 프락시를 거치면 HTTP 메시지가 **추가/변경/삭제**될 수 있고, 심지어 **본문 형식 변환**도 일어날 수 있다. 프락시가 많아질수록 벤더/구성이 다양해져 **상호운용성 문제**도 늘어난다.
- 그래서 프락시 연쇄를 지나며 **메시지가 어떻게 변했는지**를 쉽게 확인할 수 있는 진단 수단이 필요하다.

<img width="462" height="351" alt="image" src="https://github.com/user-attachments/assets/2cd3108e-9a60-47cc-af15-f2f9120a8417" />

### TRACE의 역할

- HTTP/1.1의 **TRACE 메서드**는 요청을 프락시 체인을 따라 보내서,
    - **어떤 프락시들을 거쳤는지**
    - **각 프락시가 요청을 어떻게 수정했는지**

      를 **관찰/추적**하게 해준다.

- 즉, **프락시 경로 디버깅에 유용**하다.

### TRACE 응답

- TRACE 요청이 목적지 서버에 도착하면, 서버는 **자기가 받은 “전체 요청 메시지”를 그대로 응답 본문에 담아** 클라이언트에게 돌려준다.
- 클라이언트는 응답을 보고:
    - 본문에 담긴 **서버가 실제로 받은 요청 메시지**
    - Via 헤더에 있는 **거친 프락시 목록**

      을 함께 검사할 수 있다.

- TRACE 응답의 특징:
    - 상태: **200 OK**
    - `Content-Type`: **message/http**

### Max-Forwards

<img width="459" height="356" alt="image" src="https://github.com/user-attachments/assets/0b166441-1ac8-486d-a8fb-f9f2b1693a85" />

- 보통 **TRACE**는 중간 프락시가 몇 개든 상관없이 **목적지 서버까지** 계속 전달된다.
- 하지만 **TRACE/OPTIONS 요청**이 프락시 체인을 따라 가다가 **무한 루프에 빠지는지 테스트**하거나, **중간 특정 프락시의 동작을 확인**하고 싶을 때는 **Max-Forwards 헤더**로 “몇 홉까지만 가라”를 제한할 수 있다.
- Max-Forwards는 **OPTIONS** 요청에도 동일하게 적용되어 전달 횟수를 제한한다.

### 동작 규칙

- `Max-Forwards`는 “이 요청이 앞으로 **몇 번 더 다음 홉으로 전달될 수 있는지**”를 나타내는 **정수**다.
- `Max-Forwards: 0` 이면
    - 수신자는 원 서버가 아니더라도 **더 이상 전달하지 말고**, 요청을 **클라이언트에게 그대로 돌려줘야** 한다(TRACE의 경우).
- 값이 `0`보다 크면
    - 다음 홉으로 전달할 때 **반드시 1 감소**시켜서 전달해야 한다.

### 요구사항/활용

- 모든 **프락시/게이트웨이**는 Max-Forwards를 지원해야 한다.
- 특정 홉에서의 요청을 보고 싶다면 Max-Forwards 값을 조절해 **원하는 지점에서 멈추게** 할 수 있다.

## 6.7 프락시 인증

- 프락시는 **접근 제어 장치**로 동작할 수 있고, HTTP는 이를 위해 **프락시 인증(Proxy Authentication)** 메커니즘을 정의한다.
- 사용자가 **유효한 자격(credentials)** 을 프락시에 제출하지 않으면 프락시는 콘텐츠 요청을 차단할 수 있다.

<img width="455" height="444" alt="image" src="https://github.com/user-attachments/assets/f6fc7a5c-9a37-45e3-9579-e4aaaac01f62" />

### 동작 흐름

1. 제한된 콘텐츠 요청이 프락시에 도착
2. 프락시는 **407 Proxy Authorization Required**(= 프락시 인증 필요) 상태 코드로 응답하고,
    - **Proxy-Authenticate** 헤더로 “어떤 방식/스킴으로 인증 정보를 제출하라”를 안내한다.
3. 클라이언트는 로컬에 저장된 자격을 찾거나 사용자에게 입력받아 자격을 준비한다.
4. 클라이언트는 요청을 다시 보내면서
    - **Proxy-Authorization** 헤더에 자격을 담아 전송한다.
5. 자격이 유효하면 프락시는 요청을 **다음 홉/원 서버로 전달**하고,

   유효하지 않으면 다시 **407**을 반환한다.

### 한계

- 프락시 체인(연쇄)에 **인증을 요구하는 프락시가 여러 개** 있으면, 이 방식은 일반적으로 **잘 동작하지 않는다.**
- 특정 경유지(프락시)와 자격을 정확히 매칭시키는 확장 제안이 있었지만 **널리 구현되진 않았다.**
- HTTP 인증 전반은 12장에서 자세히 다룬다.

## 6.8 프락시 상호운용성

- 클라이언트·서버·프락시는 **HTTP 명세의 서로 다른 버전**을 기준으로, **여러 벤더**가 각각 구현한다.
- 그래서 각 구현체는
    - 지원 기능이 다르고,
    - 버그도 제각각이며,
    - 어떤 경우엔 서로 다른(혹은 부분적으로 다른) 프로토콜 동작을 보일 수 있다.
- 프락시는 이런 **다양하고 때로는 이상하게 동작하는** 클라이언트와 서버 사이에서 **중개 역할**을 해야 하므로, 상호운용성 문제가 생기기 쉽다.

### 6.8.1 지원하지 않는 헤더와 메서드 다루기

- 프락시는 들어오는 **모든 헤더 필드**를 다 이해하지 못할 수 있다.
    - 프락시보다 **더 최신 표준**에서 추가된 헤더일 수도 있고,
    - 특정 애플리케이션 전용 **커스텀 헤더**일 수도 있다.
- 이때 프락시는 **모르는 헤더라도 삭제/변형하지 말고 그대로 전달**해야 한다.
- 같은 이름의 헤더가 여러 개 있을 경우에도, 그 **상대적 순서**를 **그대로 유지**해야 한다.
- 메서드도 마찬가지로, 프락시가 어떤 HTTP 메서드를 잘 몰라도 가능하면 **다음 홉으로 전달**하려고 해야 한다.
- **지원하지 않는 메서드를 통과시키지 못하는 프락시**는 현실에서 잘 살아남기 어렵다.
    - HTTP/1.1은 메서드 **확장**을 허용하고,
    - 실제로 **WebDAV**처럼 확장 메서드를 쓰는 경우가 있기 때문이다.

### 6.8.2 OPTIONS로 서버가 지원하는 기능 알아보기

- HTTP **OPTIONS** 메서드는 서버(또는 특정 리소스)가 **어떤 기능을 지원하는지**(대표적으로 **지원 메서드**)를 클라이언트/프락시가 확인할 수 있게 해준다.
- 기능 수준이 서로 다른 서버·프락시가 섞여 있을 때, 클라이언트는 **OPTIONS로 먼저 서버 능력을 확인**하면 더 쉽게 상호작용할 수 있다.

  <img width="454" height="187" alt="image" src="https://github.com/user-attachments/assets/dd351161-5578-4705-909a-1dc4ab0cd0a0" />

### 요청 대상에 따른 의미

- `OPTIONS * HTTP/1.1`

  → **서버 전체**가 지원하는 기능을 묻는 요청

- `OPTIONS /index.html HTTP/1.1` (또는 리소스 URI)

  → **특정 리소스**가 지원하는 기능을 묻는 요청


### 응답

- 성공하면 서버는 **200 OK**로 응답하고, 가능한 기능들을 설명하는 헤더들을 포함할 수 있다.
- 다만 HTTP/1.1에서 “표준으로 확실히 정의된 것”은 **Allow 헤더**뿐이다.
    - `Allow`는 서버(또는 리소스)가 지원하는 **HTTP 메서드 목록**을 알려준다.
- OPTIONS는 **응답 본문(body)을 선택적으로 포함**할 수 있지만, 그 본문 형식/내용은 **표준으로 정해져 있지 않다.**

### 6.8.3 Allow 헤더

- **Allow 엔터티 헤더**는 요청 URI가 가리키는 **자원(resource)이 지원하는 HTTP 메서드 목록**을 나열한다.
    - URI가 이면 **서버 전체가 지원하는 메서드**를 의미한다.
- 예: `Allow: GET, HEAD, PUT`

**요청에서도 쓰일 수 있음**

- Allow는 “이 새 리소스가 이런 메서드들을 지원하면 좋겠다” 같은 **추천(recommendation)** 용도로 **요청 헤더**에 넣을 수도 있다.
- 하지만 서버는 그 추천을 **반드시 따를 의무는 없다.**
- 대신 서버는 응답에 **실제로 지원하는 메서드 목록을 Allow로 다시 명시**해야 한다.

**프락시의 규칙**

- 프락시가 Allow에 나열된 메서드를 다 이해하지 못하더라도, **Allow 헤더를 수정하면 안 된다.**
- 이유: 클라이언트가 원 서버와 통신하는 다른 경로(다른 프락시/직접 연결 등)를 가질 수도 있어서, 프락시가 임의로 바꾸면 정보가 왜곡될 수 있다.
